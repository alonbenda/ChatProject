{"ast":null,"code":"import { take, switchMap, mergeAll, filter, tap, takeWhile, map, first } from 'rxjs/operators';\nimport { of } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\nconst isoDateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d*)?Z$/;\n\nconst parseIsoDateStrToDate = (_, value) => {\n  if (typeof value === 'string' && isoDateFormat.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n};\n\nconst recordSeparator = String.fromCharCode(0x1e);\n\nconst pipeParsers = (...converters) => converters.reduce((a, b) => (name, value) => b(name, a(name, value)));\n\nclass TextMessageSerializer {\n  constructor(propertyParsers) {\n    if (propertyParsers && propertyParsers.length > 0) {\n      this.reviver = pipeParsers(...propertyParsers);\n    }\n  }\n\n  serialize(messages) {\n    return messages.map(message => JSON.stringify(message)).join(recordSeparator) + recordSeparator;\n  }\n\n  deserialize({\n    data\n  }) {\n    const message = data;\n    const lastIndex = message.length - recordSeparator.length;\n\n    if (message[lastIndex] !== recordSeparator) {\n      throw new Error('Message is incomplete.');\n    }\n\n    const jsonItems = message.substring(0, lastIndex).split(recordSeparator);\n    return jsonItems.map(x => JSON.parse(x, this.reviver));\n  }\n\n}\n\nvar Transport;\n\n(function (Transport) {\n  Transport[\"longPolling\"] = \"LongPolling\";\n  Transport[\"serverSentEvents\"] = \"ServerSentEvents\";\n  Transport[\"webSockets\"] = \"WebSockets\";\n})(Transport || (Transport = {}));\n\nvar TransferFormat;\n\n(function (TransferFormat) {\n  TransferFormat[\"binary\"] = \"Binary\";\n  TransferFormat[\"text\"] = \"Text\";\n})(TransferFormat || (TransferFormat = {}));\n\nvar MessageType;\n\n(function (MessageType) {\n  /** Indicates the message is an Invocation message and implements the {@link InvocationMessage} interface. */\n  MessageType[MessageType[\"invocation\"] = 1] = \"invocation\";\n  /** Indicates the message is a StreamItem message and implements the {@link StreamItemMessage} interface. */\n\n  MessageType[MessageType[\"streamItem\"] = 2] = \"streamItem\";\n  /** Indicates the message is a Completion message and implements the {@link CompletionMessage} interface. */\n\n  MessageType[MessageType[\"completion\"] = 3] = \"completion\";\n  /** Indicates the message is a Stream Invocation message and implements the {@link StreamInvocationMessage} interface. */\n\n  MessageType[MessageType[\"streamInvocation\"] = 4] = \"streamInvocation\";\n  /** Indicates the message is a Cancel Invocation message and implements the {@link CancelInvocationMessage} interface. */\n\n  MessageType[MessageType[\"cancelInvocation\"] = 5] = \"cancelInvocation\";\n  /** Indicates the message is a Ping message and implements the {@link PingMessage} interface. */\n\n  MessageType[MessageType[\"ping\"] = 6] = \"ping\";\n  /** Indicates the message is a Close message and implements the {@link CloseMessage} interface. */\n\n  MessageType[MessageType[\"close\"] = 7] = \"close\";\n})(MessageType || (MessageType = {}));\n\nconst handshakeRequest = {\n  protocol: 'json',\n  version: 1\n};\nconst pingMessage = {\n  type: MessageType.ping\n};\nconst closeMessage = {\n  type: MessageType.close\n};\n\nconst createInvocationMessage = (target, args, invocationId, headers) => ({\n  type: MessageType.invocation,\n  headers,\n  invocationId,\n  target,\n  arguments: args\n});\n\nconst createStreamInvocationMessage = (target, args, invocationId, headers) => ({\n  type: MessageType.streamInvocation,\n  headers,\n  invocationId,\n  target,\n  arguments: args\n});\n\nconst createCancelInvocationMessage = (invocationId, headers) => ({\n  type: MessageType.cancelInvocation,\n  headers,\n  invocationId\n});\n/**\n * Represents a connection to a SignalR Hub.\n */\n\n\nclass SignalrConnection {\n  /**\n   * Creates new SignalR hub connection.\n   *\n   * @param url Connection URL.\n   * @param serializer Messages serializer.\n   */\n  constructor(url, serializer, headersFactory) {\n    this.serializer = serializer;\n    this.headersFactory = headersFactory;\n    this.lastInvocationId = 0;\n\n    this.getHeaders = (method, args) => this.headersFactory ? this.headersFactory(method, args).pipe(take(1)) : of(undefined);\n\n    this.subject = webSocket({\n      url,\n      serializer: value => this.serializer.serialize(value),\n      deserializer: event => this.serializer.deserialize(event)\n    });\n    this.maintenance$ = this.subject.multiplex(() => [handshakeRequest], () => [closeMessage], messages => messages.some(({\n      type\n    }) => type === MessageType.ping)).subscribe(_ => this.subject.next([pingMessage]));\n  }\n\n  get opened() {\n    return !this.maintenance$.closed;\n  }\n\n  /**\n  * Invokes a streaming hub method on the server using the specified name and arguments.\n  * The Observable returned by this method resolves when the server indicates it has finished invoking the stream.\n  *\n  * @param method The name of the server method to invoke.\n  * @param args The arguments used to invoke the server method.\n  * @returns\n  */\n  stream(method, ...args) {\n    this.checkOpened();\n    const invocationId = this.nextInvocationId();\n    const stream = this.getHeaders(method, args).pipe(switchMap(headers => this.subject.multiplex(() => [createStreamInvocationMessage(method, args, invocationId, headers)], () => [createCancelInvocationMessage(invocationId, headers)], messages => !!messages.find(x => x.invocationId === invocationId))));\n    return stream.pipe(mergeAll(), filter(x => x.invocationId === invocationId), tap(message => {\n      if (message.type === MessageType.completion) {\n        const {\n          error\n        } = message;\n\n        if (error) {\n          throw Error(error);\n        }\n      }\n    }), takeWhile(message => message.type !== MessageType.completion), map(message => message.item));\n  }\n  /**\n   * Invokes a hub method on the server using the specified name and arguments.\n   * The Observable returned by this method resolves when the server indicates it has finished invoking the method.\n   *\n   * @param method The name of the server method to invoke.\n   * @param args The arguments used to invoke the server method.\n   * @returns\n   */\n\n\n  invoke(method, ...args) {\n    this.checkOpened();\n    const invocationId = this.nextInvocationId();\n    this.getHeaders(method, args).pipe(map(headers => createInvocationMessage(method, args, invocationId, headers))).subscribe(invocation => this.subject.next([invocation]));\n    return this.subject.pipe(mergeAll(), filter(x => x.invocationId === invocationId), first(), map(message => {\n      const {\n        error,\n        result\n      } = message;\n\n      if (error) {\n        throw Error(error);\n      }\n\n      return result;\n    }));\n  }\n  /**\n   * Subscribes to invocations with the specified method name.\n   *\n   * @param method The name of the hub method to define.\n   * @returns Invocation's arguments Observable.\n   */\n\n\n  on(method) {\n    this.checkOpened();\n    return this.subject.pipe(mergeAll(), filter(({\n      target\n    }) => target === method), map(message => message.arguments));\n  }\n  /**\n   * Invokes a hub method on the server using the specified name and arguments.\n   * Does not wait for a response from the receiver.\n   *\n   * @param method The name of the server method to invoke.\n   * @param args The arguments used to invoke the server method.\n   */\n\n\n  send(method, ...args) {\n    this.checkOpened();\n    this.getHeaders(method, args).pipe(map(headers => createInvocationMessage(method, args, undefined, headers))).subscribe(invocation => this.subject.next([invocation]));\n  }\n  /**\n   * Closes the connection to hub and terminates subscriptions.\n   */\n\n\n  close() {\n    var _a;\n\n    (_a = this.maintenance$) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n    this.subject.complete();\n  }\n\n  checkOpened() {\n    if (!this.opened) {\n      throw \"Connection not opened\";\n    }\n  }\n\n  nextInvocationId() {\n    this.lastInvocationId++;\n    return this.lastInvocationId.toString();\n  }\n\n}\n\nconst defaultOptions = {\n  propertyParsers: []\n};\n/**\n * SignalR client allows to connect to the hubs.\n */\n\nclass SignalrClient {\n  /**\n   * Creates new SignalR client.\n   *\n   * @param httpClient HTTP client performs HTTP requests.\n   * @param options Optional: SignalR client options.\n   */\n  constructor(httpClient, options) {\n    this.httpClient = httpClient;\n    this.options = Object.assign(Object.assign({}, defaultOptions), options);\n    this.serializer = new TextMessageSerializer(this.options.propertyParsers);\n  }\n  /**\n   * Creates new SignalR client.\n   *\n   * @param httpClient HTTP client performs HTTP requests.\n   * @param configure Optional: provide action to configure SignalR client options.\n   * @returns\n   */\n\n\n  static create(httpClient, configure) {\n    let options = defaultOptions;\n\n    if (configure) {\n      configure(options);\n    }\n\n    return new SignalrClient(httpClient, options);\n  }\n  /**\n   * Connects to SignalR hub.\n   *\n   * @param hubUrl SignalR hub endpoint URL.\n   * @param accessToken Optional: access token used for client authorization.\n   * @returns SignalR hub connection.\n   */\n\n\n  connect(hubUrl, accessToken) {\n    return this.negotiate(hubUrl).pipe(map(connectionId => this.createConnection(hubUrl, connectionId, accessToken)));\n  }\n\n  negotiate(endpointBase) {\n    return this.httpClient.post(`${endpointBase}/negotiate`, null).pipe(map(response => {\n      if (!response.availableTransports.find(x => x.transport === Transport.webSockets && x.transferFormats.includes(TransferFormat.text))) {\n        throw Error('SignalrClient supports only text WebSocket transport.');\n      }\n\n      return response.connectionId;\n    }));\n  }\n\n  createConnection(endpointBase, connectionId, accessToken) {\n    const url = new URL(endpointBase, window.location.href);\n    url.protocol = url.protocol.replace(/^http/, 'ws');\n    url.searchParams.append('id', connectionId);\n\n    if (accessToken) {\n      url.searchParams.append('access_token', accessToken);\n    }\n\n    return new SignalrConnection(url.href, this.serializer, this.options.headersFactory);\n  }\n\n}\n/*\n * Public API Surface of ngx-signalr-websocket\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { SignalrClient, SignalrConnection, TextMessageSerializer, parseIsoDateStrToDate };","map":{"version":3,"names":["take","switchMap","mergeAll","filter","tap","takeWhile","map","first","of","webSocket","isoDateFormat","parseIsoDateStrToDate","_","value","test","Date","recordSeparator","String","fromCharCode","pipeParsers","converters","reduce","a","b","name","TextMessageSerializer","constructor","propertyParsers","length","reviver","serialize","messages","message","JSON","stringify","join","deserialize","data","lastIndex","Error","jsonItems","substring","split","x","parse","Transport","TransferFormat","MessageType","handshakeRequest","protocol","version","pingMessage","type","ping","closeMessage","close","createInvocationMessage","target","args","invocationId","headers","invocation","arguments","createStreamInvocationMessage","streamInvocation","createCancelInvocationMessage","cancelInvocation","SignalrConnection","url","serializer","headersFactory","lastInvocationId","getHeaders","method","pipe","undefined","subject","deserializer","event","maintenance$","multiplex","some","subscribe","next","opened","closed","stream","checkOpened","nextInvocationId","find","completion","error","item","invoke","result","on","send","_a","unsubscribe","complete","toString","defaultOptions","SignalrClient","httpClient","options","Object","assign","create","configure","connect","hubUrl","accessToken","negotiate","connectionId","createConnection","endpointBase","post","response","availableTransports","transport","webSockets","transferFormats","includes","text","URL","window","location","href","replace","searchParams","append"],"sources":["C:/Users/ALON/Projects/SOAProject/TalkBackProject/myapp/node_modules/ngx-signalr-websocket/fesm2015/ngx-signalr-websocket.js"],"sourcesContent":["import { take, switchMap, mergeAll, filter, tap, takeWhile, map, first } from 'rxjs/operators';\nimport { of } from 'rxjs';\nimport { webSocket } from 'rxjs/webSocket';\n\nconst isoDateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d*)?Z$/;\nconst parseIsoDateStrToDate = (_, value) => {\n    if (typeof value === 'string' && isoDateFormat.test(value)) {\n        return new Date(value);\n    }\n    return value;\n};\n\nconst recordSeparator = String.fromCharCode(0x1e);\nconst pipeParsers = (...converters) => converters.reduce((a, b) => (name, value) => b(name, a(name, value)));\nclass TextMessageSerializer {\n    constructor(propertyParsers) {\n        if (propertyParsers && propertyParsers.length > 0) {\n            this.reviver = pipeParsers(...propertyParsers);\n        }\n    }\n    serialize(messages) {\n        return messages.map(message => JSON.stringify(message)).join(recordSeparator) + recordSeparator;\n    }\n    deserialize({ data }) {\n        const message = data;\n        const lastIndex = message.length - recordSeparator.length;\n        if (message[lastIndex] !== recordSeparator) {\n            throw new Error('Message is incomplete.');\n        }\n        const jsonItems = message.substring(0, lastIndex).split(recordSeparator);\n        return jsonItems.map(x => JSON.parse(x, this.reviver));\n    }\n}\n\nvar Transport;\n(function (Transport) {\n    Transport[\"longPolling\"] = \"LongPolling\";\n    Transport[\"serverSentEvents\"] = \"ServerSentEvents\";\n    Transport[\"webSockets\"] = \"WebSockets\";\n})(Transport || (Transport = {}));\nvar TransferFormat;\n(function (TransferFormat) {\n    TransferFormat[\"binary\"] = \"Binary\";\n    TransferFormat[\"text\"] = \"Text\";\n})(TransferFormat || (TransferFormat = {}));\n\nvar MessageType;\n(function (MessageType) {\n    /** Indicates the message is an Invocation message and implements the {@link InvocationMessage} interface. */\n    MessageType[MessageType[\"invocation\"] = 1] = \"invocation\";\n    /** Indicates the message is a StreamItem message and implements the {@link StreamItemMessage} interface. */\n    MessageType[MessageType[\"streamItem\"] = 2] = \"streamItem\";\n    /** Indicates the message is a Completion message and implements the {@link CompletionMessage} interface. */\n    MessageType[MessageType[\"completion\"] = 3] = \"completion\";\n    /** Indicates the message is a Stream Invocation message and implements the {@link StreamInvocationMessage} interface. */\n    MessageType[MessageType[\"streamInvocation\"] = 4] = \"streamInvocation\";\n    /** Indicates the message is a Cancel Invocation message and implements the {@link CancelInvocationMessage} interface. */\n    MessageType[MessageType[\"cancelInvocation\"] = 5] = \"cancelInvocation\";\n    /** Indicates the message is a Ping message and implements the {@link PingMessage} interface. */\n    MessageType[MessageType[\"ping\"] = 6] = \"ping\";\n    /** Indicates the message is a Close message and implements the {@link CloseMessage} interface. */\n    MessageType[MessageType[\"close\"] = 7] = \"close\";\n})(MessageType || (MessageType = {}));\nconst handshakeRequest = { protocol: 'json', version: 1 };\nconst pingMessage = { type: MessageType.ping };\nconst closeMessage = { type: MessageType.close };\nconst createInvocationMessage = (target, args, invocationId, headers) => ({\n    type: MessageType.invocation,\n    headers,\n    invocationId,\n    target,\n    arguments: args\n});\nconst createStreamInvocationMessage = (target, args, invocationId, headers) => ({\n    type: MessageType.streamInvocation,\n    headers,\n    invocationId,\n    target,\n    arguments: args,\n});\nconst createCancelInvocationMessage = (invocationId, headers) => ({\n    type: MessageType.cancelInvocation,\n    headers,\n    invocationId\n});\n\n/**\n * Represents a connection to a SignalR Hub.\n */\nclass SignalrConnection {\n    /**\n     * Creates new SignalR hub connection.\n     *\n     * @param url Connection URL.\n     * @param serializer Messages serializer.\n     */\n    constructor(url, serializer, headersFactory) {\n        this.serializer = serializer;\n        this.headersFactory = headersFactory;\n        this.lastInvocationId = 0;\n        this.getHeaders = (method, args) => this.headersFactory ? this.headersFactory(method, args).pipe(take(1)) : of(undefined);\n        this.subject = webSocket({\n            url,\n            serializer: value => this.serializer.serialize(value),\n            deserializer: event => this.serializer.deserialize(event),\n        });\n        this.maintenance$ = this.subject\n            .multiplex(() => [handshakeRequest], () => [closeMessage], (messages) => messages.some(({ type }) => type === MessageType.ping))\n            .subscribe(_ => this.subject.next([pingMessage]));\n    }\n    get opened() { return !this.maintenance$.closed; }\n    ;\n    /**\n    * Invokes a streaming hub method on the server using the specified name and arguments.\n    * The Observable returned by this method resolves when the server indicates it has finished invoking the stream.\n    *\n    * @param method The name of the server method to invoke.\n    * @param args The arguments used to invoke the server method.\n    * @returns\n    */\n    stream(method, ...args) {\n        this.checkOpened();\n        const invocationId = this.nextInvocationId();\n        const stream = this.getHeaders(method, args)\n            .pipe(switchMap(headers => this.subject.multiplex(() => [createStreamInvocationMessage(method, args, invocationId, headers)], () => [createCancelInvocationMessage(invocationId, headers)], messages => !!messages.find(x => x.invocationId === invocationId))));\n        return stream.pipe(mergeAll(), filter(x => x.invocationId === invocationId), tap(message => {\n            if (message.type === MessageType.completion) {\n                const { error } = message;\n                if (error) {\n                    throw Error(error);\n                }\n            }\n        }), takeWhile(message => message.type !== MessageType.completion), map(message => message.item));\n    }\n    /**\n     * Invokes a hub method on the server using the specified name and arguments.\n     * The Observable returned by this method resolves when the server indicates it has finished invoking the method.\n     *\n     * @param method The name of the server method to invoke.\n     * @param args The arguments used to invoke the server method.\n     * @returns\n     */\n    invoke(method, ...args) {\n        this.checkOpened();\n        const invocationId = this.nextInvocationId();\n        this.getHeaders(method, args)\n            .pipe(map(headers => createInvocationMessage(method, args, invocationId, headers)))\n            .subscribe(invocation => this.subject.next([invocation]));\n        return this.subject\n            .pipe(mergeAll(), filter(x => x.invocationId === invocationId), first(), map(message => {\n            const { error, result } = message;\n            if (error) {\n                throw Error(error);\n            }\n            return result;\n        }));\n    }\n    /**\n     * Subscribes to invocations with the specified method name.\n     *\n     * @param method The name of the hub method to define.\n     * @returns Invocation's arguments Observable.\n     */\n    on(method) {\n        this.checkOpened();\n        return this.subject\n            .pipe(mergeAll(), filter(({ target }) => target === method), map(message => message.arguments));\n    }\n    /**\n     * Invokes a hub method on the server using the specified name and arguments.\n     * Does not wait for a response from the receiver.\n     *\n     * @param method The name of the server method to invoke.\n     * @param args The arguments used to invoke the server method.\n     */\n    send(method, ...args) {\n        this.checkOpened();\n        this.getHeaders(method, args)\n            .pipe(map(headers => createInvocationMessage(method, args, undefined, headers)))\n            .subscribe(invocation => this.subject.next([invocation]));\n    }\n    /**\n     * Closes the connection to hub and terminates subscriptions.\n     */\n    close() {\n        var _a;\n        (_a = this.maintenance$) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        this.subject.complete();\n    }\n    checkOpened() {\n        if (!this.opened) {\n            throw \"Connection not opened\";\n        }\n    }\n    nextInvocationId() {\n        this.lastInvocationId++;\n        return this.lastInvocationId.toString();\n    }\n}\n\nconst defaultOptions = {\n    propertyParsers: []\n};\n/**\n * SignalR client allows to connect to the hubs.\n */\nclass SignalrClient {\n    /**\n     * Creates new SignalR client.\n     *\n     * @param httpClient HTTP client performs HTTP requests.\n     * @param options Optional: SignalR client options.\n     */\n    constructor(httpClient, options) {\n        this.httpClient = httpClient;\n        this.options = Object.assign(Object.assign({}, defaultOptions), options);\n        this.serializer = new TextMessageSerializer(this.options.propertyParsers);\n    }\n    /**\n     * Creates new SignalR client.\n     *\n     * @param httpClient HTTP client performs HTTP requests.\n     * @param configure Optional: provide action to configure SignalR client options.\n     * @returns\n     */\n    static create(httpClient, configure) {\n        let options = defaultOptions;\n        if (configure) {\n            configure(options);\n        }\n        return new SignalrClient(httpClient, options);\n    }\n    /**\n     * Connects to SignalR hub.\n     *\n     * @param hubUrl SignalR hub endpoint URL.\n     * @param accessToken Optional: access token used for client authorization.\n     * @returns SignalR hub connection.\n     */\n    connect(hubUrl, accessToken) {\n        return this.negotiate(hubUrl)\n            .pipe(map(connectionId => this.createConnection(hubUrl, connectionId, accessToken)));\n    }\n    negotiate(endpointBase) {\n        return this.httpClient.post(`${endpointBase}/negotiate`, null)\n            .pipe(map(response => {\n            if (!response.availableTransports\n                .find(x => x.transport === Transport.webSockets && x.transferFormats.includes(TransferFormat.text))) {\n                throw Error('SignalrClient supports only text WebSocket transport.');\n            }\n            return response.connectionId;\n        }));\n    }\n    createConnection(endpointBase, connectionId, accessToken) {\n        const url = new URL(endpointBase, window.location.href);\n        url.protocol = url.protocol.replace(/^http/, 'ws');\n        url.searchParams.append('id', connectionId);\n        if (accessToken) {\n            url.searchParams.append('access_token', accessToken);\n        }\n        return new SignalrConnection(url.href, this.serializer, this.options.headersFactory);\n    }\n}\n\n/*\n * Public API Surface of ngx-signalr-websocket\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SignalrClient, SignalrConnection, TextMessageSerializer, parseIsoDateStrToDate };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}