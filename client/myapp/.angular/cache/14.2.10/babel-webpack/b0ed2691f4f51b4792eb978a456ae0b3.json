{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Arg, Subject } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\n\nexport var HubConnectionState;\n\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[HubConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\n  /** The hub connection is connected. */\n\n  HubConnectionState[HubConnectionState[\"Connected\"] = 1] = \"Connected\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\n\n\nvar HubConnection =\n/** @class */\nfunction () {\n  function HubConnection(connection, logger, protocol) {\n    var _this = this;\n\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.handshakeProtocol = new HandshakeProtocol();\n\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.id = 0;\n    this.receivedHandshakeResponse = false;\n    this.connectionState = HubConnectionState.Disconnected;\n    this.cachedPingMessage = this.protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n\n\n  HubConnection.create = function (connection, logger, protocol) {\n    return new HubConnection(connection, logger, protocol);\n  };\n\n  Object.defineProperty(HubConnection.prototype, \"state\", {\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n\n  HubConnection.prototype.start = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakeRequest, handshakePromise;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            this.receivedHandshakeResponse = false;\n            handshakePromise = new Promise(function (resolve, reject) {\n              _this.handshakeResolver = resolve;\n              _this.handshakeRejecter = reject;\n            });\n            return [4\n            /*yield*/\n            , this.connection.start(this.protocol.transferFormat)];\n\n          case 1:\n            _a.sent();\n\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4\n            /*yield*/\n            , this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n\n          case 2:\n            _a.sent();\n\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\"); // defensively cleanup timeout in case we receive a message from the server before we finish start\n\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval(); // Wait for the handshake to complete before marking connection as connected\n\n            return [4\n            /*yield*/\n            , handshakePromise];\n\n          case 3:\n            // Wait for the handshake to complete before marking connection as connected\n            _a.sent();\n\n            this.connectionState = HubConnectionState.Connected;\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.stop = function () {\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    return this.connection.stop();\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n\n\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createStreamInvocation(methodName, args);\n    var promiseQueue;\n    var subject = new Subject();\n\n    subject.cancelCallback = function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n\n      var cancelMessage = _this.protocol.writeMessage(cancelInvocation);\n\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(function () {\n        return _this.sendMessage(cancelMessage);\n      });\n    };\n\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === MessageType.Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    promiseQueue = this.sendMessage(message).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    return subject;\n  };\n\n  HubConnection.prototype.sendMessage = function (message) {\n    this.resetKeepAliveInterval();\n    return this.connection.send(message);\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createInvocation(methodName, args, true);\n    var message = this.protocol.writeMessage(invocationDescriptor);\n    return this.sendMessage(message);\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n\n\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    var invocationDescriptor = this.createInvocation(methodName, args, false);\n    var p = new Promise(function (resolve, reject) {\n      // invocationId will always have a value for a non-blocking invocation\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n          }\n        }\n      };\n\n      var message = _this.protocol.writeMessage(invocationDescriptor);\n\n      _this.sendMessage(message).catch(function (e) {\n        reject(e); // invocationId will always have a value for a non-blocking invocation\n\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n\n\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    } // Preventing adding the same handler multiple times.\n\n\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n\n    this.methods[methodName].push(newMethod);\n  };\n\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n\n    if (!handlers) {\n      return;\n    }\n\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n\n\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    } // Data may have all been read when processing handshake response\n\n\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n\n            if (callback != null) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n\n              callback(message);\n            }\n\n            break;\n\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\"); // We don't want to wait on the stop itself.\n            // tslint:disable-next-line:no-floating-promises\n\n            this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined);\n            break;\n\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\n            break;\n        }\n      }\n    }\n\n    this.resetTimeoutPeriod();\n  };\n\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n\n    var responseMessage;\n    var remainingData;\n\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message); // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n\n      this.connection.stop(error);\n      this.handshakeRejecter(error);\n      throw error;\n    }\n\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message);\n      this.handshakeRejecter(message); // We don't want to wait on the stop itself.\n      // tslint:disable-next-line:no-floating-promises\n\n      this.connection.stop(new Error(message));\n      throw new Error(message);\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n\n    this.handshakeResolver();\n    return remainingData;\n  };\n\n  HubConnection.prototype.resetKeepAliveInterval = function () {\n    var _this = this;\n\n    this.cleanupPingTimer();\n    this.pingServerHandle = setTimeout(function () {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!(this.connectionState === HubConnectionState.Connected)) return [3\n              /*break*/\n              , 4];\n              _b.label = 1;\n\n            case 1:\n              _b.trys.push([1, 3,, 4]);\n\n              return [4\n              /*yield*/\n              , this.sendMessage(this.cachedPingMessage)];\n\n            case 2:\n              _b.sent();\n\n              return [3\n              /*break*/\n              , 4];\n\n            case 3:\n              _a = _b.sent(); // We don't care about the error. It should be seen elsewhere in the client.\n              // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n\n              this.cleanupPingTimer();\n              return [3\n              /*break*/\n              , 4];\n\n            case 4:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }, this.keepAliveIntervalInMilliseconds);\n  };\n\n  HubConnection.prototype.resetTimeoutPeriod = function () {\n    var _this = this;\n\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n    }\n  };\n\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n\n    if (methods) {\n      methods.forEach(function (m) {\n        return m.apply(_this, invocationMessage.arguments);\n      });\n\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message); // We don't need to wait on this Promise.\n        // tslint:disable-next-line:no-floating-promises\n\n        this.connection.stop(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n\n  HubConnection.prototype.connectionClosed = function (error) {\n    var _this = this;\n\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    this.connectionState = HubConnectionState.Disconnected; // if handshake is in progress start will be waiting for the handshake promise, so we complete it\n    // if it has already completed this should just noop\n\n    if (this.handshakeRejecter) {\n      this.handshakeRejecter(error);\n    }\n\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(null, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\n    });\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    this.closedCallbacks.forEach(function (c) {\n      return c.apply(_this, [error]);\n    });\n  };\n\n  HubConnection.prototype.cleanupPingTimer = function () {\n    if (this.pingServerHandle) {\n      clearTimeout(this.pingServerHandle);\n    }\n  };\n\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {\n    if (nonblocking) {\n      return {\n        arguments: args,\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    } else {\n      var id = this.id;\n      this.id++;\n      return {\n        arguments: args,\n        invocationId: id.toString(),\n        target: methodName,\n        type: MessageType.Invocation\n      };\n    }\n  };\n\n  HubConnection.prototype.createStreamInvocation = function (methodName, args) {\n    var id = this.id;\n    this.id++;\n    return {\n      arguments: args,\n      invocationId: id.toString(),\n      target: methodName,\n      type: MessageType.StreamInvocation\n    };\n  };\n\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n\n  return HubConnection;\n}();\n\nexport { HubConnection };","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","HandshakeProtocol","MessageType","LogLevel","Arg","Subject","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","HubConnectionState","HubConnection","connection","logger","protocol","_this","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","handshakeProtocol","onreceive","data","processIncomingData","onclose","error","connectionClosed","callbacks","methods","closedCallbacks","id","receivedHandshakeResponse","connectionState","Disconnected","cachedPingMessage","writeMessage","type","Ping","create","Object","defineProperty","prototype","get","enumerable","configurable","start","handshakeRequest","handshakePromise","_a","name","version","log","Debug","handshakeResolver","handshakeRejecter","transferFormat","sendMessage","writeHandshakeRequest","Information","cleanupTimeout","resetTimeoutPeriod","resetKeepAliveInterval","Connected","stop","cleanupPingTimer","stream","methodName","args","_i","arguments","invocationDescriptor","createStreamInvocation","promiseQueue","subject","cancelCallback","cancelInvocation","createCancelInvocation","invocationId","cancelMessage","invocationEvent","Completion","Error","complete","item","message","catch","send","createInvocation","invoke","p","on","newMethod","toLowerCase","indexOf","off","method","handlers","removeIdx","splice","callback","processHandshakeResponse","messages","parseMessages","messages_1","Invocation","invokeClientMethod","StreamItem","Close","undefined","Warning","responseMessage","remainingData","parseHandshakeResponse","pingServerHandle","setTimeout","_b","features","inherentKeepAlive","timeoutHandle","serverTimeout","invocationMessage","target","forEach","m","keys","key","c","clearTimeout","nonblocking","toString","StreamInvocation","CancelInvocation"],"sources":["C:/Users/ALON/Projects/SOAProject/TalkBackProject/myapp/node_modules/@aspnet/signalr/dist/esm/HubConnection.js"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nvar __generator = (this && this.__generator) || function (thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n};\r\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\r\nimport { MessageType } from \"./IHubProtocol\";\r\nimport { LogLevel } from \"./ILogger\";\r\nimport { Arg, Subject } from \"./Utils\";\r\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\r\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport var HubConnectionState;\r\n(function (HubConnectionState) {\r\n    /** The hub connection is disconnected. */\r\n    HubConnectionState[HubConnectionState[\"Disconnected\"] = 0] = \"Disconnected\";\r\n    /** The hub connection is connected. */\r\n    HubConnectionState[HubConnectionState[\"Connected\"] = 1] = \"Connected\";\r\n})(HubConnectionState || (HubConnectionState = {}));\r\n/** Represents a connection to a SignalR Hub. */\r\nvar HubConnection = /** @class */ (function () {\r\n    function HubConnection(connection, logger, protocol) {\r\n        var _this = this;\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n        this.connection.onreceive = function (data) { return _this.processIncomingData(data); };\r\n        this.connection.onclose = function (error) { return _this.connectionClosed(error); };\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.id = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    HubConnection.create = function (connection, logger, protocol) {\r\n        return new HubConnection(connection, logger, protocol);\r\n    };\r\n    Object.defineProperty(HubConnection.prototype, \"state\", {\r\n        /** Indicates the state of the {@link HubConnection} to the server. */\r\n        get: function () {\r\n            return this.connectionState;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.start = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var handshakeRequest, handshakePromise;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        handshakeRequest = {\r\n                            protocol: this.protocol.name,\r\n                            version: this.protocol.version,\r\n                        };\r\n                        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n                        this.receivedHandshakeResponse = false;\r\n                        handshakePromise = new Promise(function (resolve, reject) {\r\n                            _this.handshakeResolver = resolve;\r\n                            _this.handshakeRejecter = reject;\r\n                        });\r\n                        return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n                        return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\r\n                    case 2:\r\n                        _a.sent();\r\n                        this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\r\n                        // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n                        this.cleanupTimeout();\r\n                        this.resetTimeoutPeriod();\r\n                        this.resetKeepAliveInterval();\r\n                        // Wait for the handshake to complete before marking connection as connected\r\n                        return [4 /*yield*/, handshakePromise];\r\n                    case 3:\r\n                        // Wait for the handshake to complete before marking connection as connected\r\n                        _a.sent();\r\n                        this.connectionState = HubConnectionState.Connected;\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.stop = function () {\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        return this.connection.stop();\r\n    };\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    HubConnection.prototype.stream = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createStreamInvocation(methodName, args);\r\n        var promiseQueue;\r\n        var subject = new Subject();\r\n        subject.cancelCallback = function () {\r\n            var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\r\n            var cancelMessage = _this.protocol.writeMessage(cancelInvocation);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n            return promiseQueue.then(function () {\r\n                return _this.sendMessage(cancelMessage);\r\n            });\r\n        };\r\n        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            }\r\n            else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    }\r\n                    else {\r\n                        subject.complete();\r\n                    }\r\n                }\r\n                else {\r\n                    subject.next((invocationEvent.item));\r\n                }\r\n            }\r\n        };\r\n        var message = this.protocol.writeMessage(invocationDescriptor);\r\n        promiseQueue = this.sendMessage(message)\r\n            .catch(function (e) {\r\n            subject.error(e);\r\n            delete _this.callbacks[invocationDescriptor.invocationId];\r\n        });\r\n        return subject;\r\n    };\r\n    HubConnection.prototype.sendMessage = function (message) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    HubConnection.prototype.send = function (methodName) {\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createInvocation(methodName, args, true);\r\n        var message = this.protocol.writeMessage(invocationDescriptor);\r\n        return this.sendMessage(message);\r\n    };\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    HubConnection.prototype.invoke = function (methodName) {\r\n        var _this = this;\r\n        var args = [];\r\n        for (var _i = 1; _i < arguments.length; _i++) {\r\n            args[_i - 1] = arguments[_i];\r\n        }\r\n        var invocationDescriptor = this.createInvocation(methodName, args, false);\r\n        var p = new Promise(function (resolve, reject) {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                }\r\n                else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        }\r\n                        else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    }\r\n                    else {\r\n                        reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\r\n                    }\r\n                }\r\n            };\r\n            var message = _this.protocol.writeMessage(invocationDescriptor);\r\n            _this.sendMessage(message)\r\n                .catch(function (e) {\r\n                reject(e);\r\n                // invocationId will always have a value for a non-blocking invocation\r\n                delete _this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n        });\r\n        return p;\r\n    };\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    HubConnection.prototype.on = function (methodName, newMethod) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n        this.methods[methodName].push(newMethod);\r\n    };\r\n    HubConnection.prototype.off = function (methodName, method) {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n        methodName = methodName.toLowerCase();\r\n        var handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            var removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            delete this.methods[methodName];\r\n        }\r\n    };\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    HubConnection.prototype.onclose = function (callback) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    };\r\n    HubConnection.prototype.processIncomingData = function (data) {\r\n        this.cleanupTimeout();\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            var messages = this.protocol.parseMessages(data, this.logger);\r\n            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\r\n                var message = messages_1[_i];\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        var callback = this.callbacks[message.invocationId];\r\n                        if (callback != null) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n                        // We don't want to wait on the stop itself.\r\n                        // tslint:disable-next-line:no-floating-promises\r\n                        this.connection.stop(message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined);\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        this.resetTimeoutPeriod();\r\n    };\r\n    HubConnection.prototype.processHandshakeResponse = function (data) {\r\n        var _a;\r\n        var responseMessage;\r\n        var remainingData;\r\n        try {\r\n            _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\r\n        }\r\n        catch (e) {\r\n            var message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n            var error = new Error(message);\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(error);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            var message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n            this.handshakeRejecter(message);\r\n            // We don't want to wait on the stop itself.\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.connection.stop(new Error(message));\r\n            throw new Error(message);\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    };\r\n    HubConnection.prototype.resetKeepAliveInterval = function () {\r\n        var _this = this;\r\n        this.cleanupPingTimer();\r\n        this.pingServerHandle = setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        _a = _b.sent();\r\n                        // We don't care about the error. It should be seen elsewhere in the client.\r\n                        // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                        this.cleanupPingTimer();\r\n                        return [3 /*break*/, 4];\r\n                    case 4: return [2 /*return*/];\r\n                }\r\n            });\r\n        }); }, this.keepAliveIntervalInMilliseconds);\r\n    };\r\n    HubConnection.prototype.resetTimeoutPeriod = function () {\r\n        var _this = this;\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);\r\n        }\r\n    };\r\n    HubConnection.prototype.serverTimeout = function () {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    };\r\n    HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\r\n        var _this = this;\r\n        var methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                var message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n                // We don't need to wait on this Promise.\r\n                // tslint:disable-next-line:no-floating-promises\r\n                this.connection.stop(new Error(message));\r\n            }\r\n        }\r\n        else {\r\n            this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\r\n        }\r\n    };\r\n    HubConnection.prototype.connectionClosed = function (error) {\r\n        var _this = this;\r\n        var callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        // if handshake is in progress start will be waiting for the handshake promise, so we complete it\r\n        // if it has already completed this should just noop\r\n        if (this.handshakeRejecter) {\r\n            this.handshakeRejecter(error);\r\n        }\r\n        Object.keys(callbacks)\r\n            .forEach(function (key) {\r\n            var callback = callbacks[key];\r\n            callback(null, error ? error : new Error(\"Invocation canceled due to connection being closed.\"));\r\n        });\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });\r\n    };\r\n    HubConnection.prototype.cleanupPingTimer = function () {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.cleanupTimeout = function () {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    };\r\n    HubConnection.prototype.createInvocation = function (methodName, args, nonblocking) {\r\n        if (nonblocking) {\r\n            return {\r\n                arguments: args,\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n        else {\r\n            var id = this.id;\r\n            this.id++;\r\n            return {\r\n                arguments: args,\r\n                invocationId: id.toString(),\r\n                target: methodName,\r\n                type: MessageType.Invocation,\r\n            };\r\n        }\r\n    };\r\n    HubConnection.prototype.createStreamInvocation = function (methodName, args) {\r\n        var id = this.id;\r\n        this.id++;\r\n        return {\r\n            arguments: args,\r\n            invocationId: id.toString(),\r\n            target: methodName,\r\n            type: MessageType.StreamInvocation,\r\n        };\r\n    };\r\n    HubConnection.prototype.createCancelInvocation = function (id) {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    };\r\n    return HubConnection;\r\n}());\r\nexport { HubConnection };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}